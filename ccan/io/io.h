/* Licensed under LGPLv2.1+ - see LICENSE file for details */
#ifndef CCAN_IO_H
#define CCAN_IO_H
#include <ccan/typesafe_cb/typesafe_cb.h>
#include <ccan/time/time.h>
#include <stdbool.h>
#include <unistd.h>

/**
 * struct io_plan - pointer to return from a setup function.
 *
 * A plan of what IO to do, when.
 */
struct io_plan;

/**
 * struct io_next - pointer to what we're going to do next.
 *
 * Bundles up callbacks, generated by io_next().
 */
struct io_next;

/**
 * io_new_conn - create a new connection.
 * @fd: the file descriptor.
 * @start: the first function to call.
 * @finish: the function to call when it's closed or fails.
 * @arg: the argument to both @start and @finish.
 *
 * This creates a connection which owns @fd.  @start will be called on the
 * next return to io_loop(), and @finish will be called when an I/O operation
 * fails, or you call io_close() on the connection.
 *
 * The @start function must call one of the io queueing functions
 * (eg. io_read, io_write) and return the next function to call once
 * that is done using io_next().  The alternative is to call io_close().
 *
 * Returns NULL on error (and sets errno).
 */
#define io_new_conn(fd, start, finish, arg)				\
	io_new_conn_((fd),						\
		     typesafe_cb_preargs(struct io_plan *, void *,	\
					 (start), (arg), struct io_conn *), \
		     typesafe_cb_preargs(void, void *, (finish), (arg),	\
					 struct io_conn *),		\
		     (arg))
struct io_conn *io_new_conn_(int fd,
			     struct io_plan *(*start)(struct io_conn *, void *),
			     void (*finish)(struct io_conn *, void *),
			     void *arg);

/**
 * io_new_listener - create a new accepting listener.
 * @fd: the file descriptor.
 * @start: the first function to call on new connections.
 * @finish: the function to call when the connection is closed or fails.
 * @arg: the argument to both @start and @finish.
 *
 * When @fd becomes readable, we accept() and turn that fd into a new
 * connection.
 *
 * Returns NULL on error (and sets errno).
 */
#define io_new_listener(fd, start, finish, arg)				\
	io_new_listener_((fd),						\
			 typesafe_cb_preargs(struct io_plan *, void *,	\
					     (start), (arg),		\
					     struct io_conn *),		\
			 typesafe_cb_preargs(void, void *, (finish),	\
					     (arg), struct io_conn *),	\
			 (arg))
struct io_listener *io_new_listener_(int fd,
				     struct io_plan *(*start)(struct io_conn *,
							      void *arg),
				     void (*finish)(struct io_conn *,
						    void *arg),
				     void *arg);

/**
 * io_close_listener - delete a listener.
 * @listener: the listener returned from io_new_listener.
 *
 * This closes the fd and frees @listener.
 */
void io_close_listener(struct io_listener *listener);

/**
 * io_write - queue data to be written.
 * @data: the data buffer.
 * @len: the length to write.
 * @next: what to call next.
 *
 * This will queue the data buffer for writing.  Once it's all written, the
 * function registered with io_next() will be called: on an error, the finish
 * function is called instead.
 *
 * Note that the I/O may actually be done immediately.
 */
struct io_plan *io_write(const void *data, size_t len, struct io_next *next);

/**
 * io_read - queue buffer to be read.
 * @data: the data buffer.
 * @len: the length to read.
 * @next: what to call next.
 *
 * This will queue the data buffer for reading.  Once it's all read, the
 * function registered with io_next() will be called: on an error, the finish
 * function is called instead.
 *
 * Note that the I/O may actually be done immediately.
 */
struct io_plan *io_read(void *data, size_t len, struct io_next *next);

/**
 * io_read_partial - queue buffer to be read (partial OK).
 * @data: the data buffer.
 * @len: the maximum length to read, set to the length actually read.
 * @next: what to call next.
 *
 * This will queue the data buffer for reading.  Once any data is
 * read, @len is updated and the function registered with io_next()
 * will be called: on an error, the finish function is called instead.
 *
 * Note that the I/O may actually be done immediately.
 */
struct io_plan *io_read_partial(void *data, size_t *len, struct io_next *next);

/**
 * io_write_partial - queue data to be written (partial OK).
 * @data: the data buffer.
 * @len: the maximum length to write, set to the length actually written.
 * @next: what to call next.
 *
 * This will queue the data buffer for writing.  Once any data is
 * written, @len is updated and the function registered with io_next()
 * will be called: on an error, the finish function is called instead.
 *
 * Note that the I/O may actually be done immediately.
 */
struct io_plan *io_write_partial(const void *data, size_t *len,
			       struct io_next *next);

/**
 * io_idle - explicitly note that this connection will do nothing.
 * @conn: the current connection.
 *
 * This indicates the connection is idle: some other function will
 * later call io_read/io_write etc. (or io_close) on it, in which case
 * it will do that.
 */
struct io_plan *io_idle(struct io_conn *conn);

/**
 * io_timeout - set timeout function if the callback doesn't fire.
 * @conn: the current connection.
 * @ts: how long until the timeout should be called.
 * @next: function to call.
 * @arg: argument to @next.
 *
 * If the usual next callback is not called for this connection before @ts,
 * this function will be called.  If next callback is called, the timeout
 * is automatically removed.
 *
 * Returns false on allocation failure.  A connection can only have one
 * timeout.
 */
#define io_timeout(conn, ts, next, arg) \
	io_timeout_((conn), (ts),					\
		    typesafe_cb_preargs(struct io_plan *, void *,	\
					(next), (arg),			\
					struct io_conn *),		\
		    (arg))

bool io_timeout_(struct io_conn *conn, struct timespec ts,
		 struct io_plan *(*next)(struct io_conn *, void *), void *arg);

/**
 * io_duplex - split an fd into two connections.
 * @conn: a connection.
 * @start: the first function to call.
 * @finish: the function to call when it's closed or fails.
 * @arg: the argument to both @start and @finish.
 *
 * Sometimes you want to be able to simultaneously read and write on a
 * single fd, but io forces a linear call sequence.  The solition is
 * to have two connections for the same fd, and use one for read
 * operations and one for write.
 *
 * You must io_close() both of them to close the fd.
 */
#define io_duplex(conn, start, finish, arg)				\
	io_duplex_((conn),						\
		   typesafe_cb_preargs(struct io_plan *, void *,	\
				       (start), (arg), struct io_conn *), \
		   typesafe_cb_preargs(void, void *, (finish), (arg),	\
				       struct io_conn *),		\
		   (arg))

struct io_conn *io_duplex_(struct io_conn *conn,
			   struct io_plan *(*start)(struct io_conn *, void *),
			   void (*finish)(struct io_conn *, void *),
			   void *arg);

/**
 * io_wake - wake up and idle connection.
 * @conn: an idle connection.
 * @next: the next function to call once queued IO is complete.
 * @arg: the argument to @next.
 *
 * This makes @conn run its @next function the next time around the
 * io_loop().
 */
#define io_wake(conn, next, arg)					\
	io_wake_((conn),						\
		 typesafe_cb_preargs(struct io_plan *, void *,		\
				     (next), (arg), struct io_conn *),	\
		 (arg))
void io_wake_(struct io_conn *conn,
	      struct io_plan *(*next)(struct io_conn *, void *), void *arg);

/**
 * io_break - return from io_loop()
 * @arg: non-NULL value to return from io_loop().
 * @next: what to call next (can be NULL if we expect no return).
 *
 * This breaks out of the io_loop.  As soon as the current @next
 * function returns, any io_closed()'d connections will have their
 * finish callbacks called, then io_loop() with return with @arg.
 *
 * If io_loop() is called again, then @next will be called.
 */
struct io_plan *io_break(void *arg, struct io_next *next);

/**
 * io_next - indicate what callback to call next.
 * @conn: this connection.
 * @next: the next function to call once queued IO is complete.
 * @arg: the argument to @next.
 *
 * Every @next (or @start) function should "return io_next(...);" once
 * they have indicated what io to perform (eg. io_write, io_idle).
 * The exception is io_close(), which can be used instead of io_next().
 *
 * Note that as an optimization, the next function may be called
 * immediately, which is why this should be the last statement in your
 * function.
 */
#define io_next(conn, next, arg)					\
	io_next_((conn),						\
		 typesafe_cb_preargs(struct io_plan *, void *,		\
				     (next), (arg), struct io_conn *),	\
		 (arg))
struct io_next *io_next_(struct io_conn *conn,
			 struct io_plan *(*next)(struct io_conn *, void *arg),
			 void *arg);

/* FIXME: io_recvfrom/io_sendto */

/**
 * io_close - terminate a connection.
 * @conn: any connection.
 *
 * The schedules a connection to be closed.  It can be done on any
 * connection, whether it has I/O queued or not (though that I/O may
 * be performed first).
 *
 * It's common to 'return io_close(...)' from a @next function, but
 * io_close can also be used as an argument to io_next().
 */
struct io_plan *io_close(struct io_conn *, void *unused);

/**
 * io_loop - process fds until all closed on io_break.
 *
 * This is the core loop; it exits with the io_break() arg, or NULL if
 * all connections and listeners are closed.
 */
void *io_loop(void);
#endif /* CCAN_IO_H */
